# Day 3 – Interview Questions: API Gateway vs Load Balancer

## 1. What is the difference between an API Gateway and a Load Balancer?

An API Gateway operates at the application boundary and handles client-facing concerns such as authentication, rate limiting, and routing to services.
A Load Balancer operates at the infrastructure level and handles instance-level concerns such as health checks, load distribution, and failover.

---

## 2. Can an API Gateway replace a Load Balancer?

No, an API Gateway cannot replace a Load Balancer. An API Gateway operates at the client and application boundary, 
deciding which backend service should handle a request. A Load Balancer operates at the infrastructure level and is responsible 
for instance-level concerns such as health checks, load distribution, and failover. Both are required and solve different problems.

---

## 3. Why are both used in microservice architectures?

Microservices require:
- A single entry point for clients (API Gateway)
- Reliable traffic distribution and failure handling (Load Balancer)

Using both ensures scalability, reliability, and clean separation of concerns.

- API Gateway decides WHAT service to call.
- Load Balancer decides WHICH INSTANCE should handle it.

---

## 4. Where does authentication typically happen?

Authentication typically happens at the API Gateway so that backend services can remain focused on business logic.

---

## 5. Why not put one load balancer for all services?

You can, but per-service load balancers allow independent scaling and failure isolation.

---

## 6. Can Kubernetes replace this?

Kubernetes provides service discovery and internal load balancing, but API Gateway is still required for client-facing concerns.
---

## 7. How does the API Gateway know which service to call?

The API Gateway does not guess. It follows explicit routing rules. Routing Mechanisms (Most Common → Less Common):

a. Path-based routing (most common)
    - /api/users/**     → User Service
    - /api/orders/**    → Order Service
    - /api/payments/**  → Payment Service

b. Header-based routing
    - X-Service-Type: PAYMENT → Payment Service
    - Used in Internal APIs.

c. Method-based routing
    - POST /transactions → Payment Service
    - GET  /transactions → Reporting Service

d. Version-based routing
    - /v1/users → user-service-v1
    - /v2/users → user-service-v2

---

## 8. Suppose your API Gateway is down. What happens to your system? How would you design to avoid this becoming a single point of failure?

- If an API Gateway instance goes down, it should not impact the system because API Gateways are typically deployed in a highly available manner.
- In cloud environments like Azure, the API Gateway runs behind a managed load balancer or front-door service. Multiple gateway instances 
  are deployed across availability zones, and health checks ensure that traffic is routed only to healthy instances.
- If one instance fails, the load balancer stops routing traffic to it and directs requests to other healthy gateway instances. 
  Auto-scaling can also spin up new instances if required.
- This design ensures that the API Gateway itself does not become a single point of failure.
- Clients never hit a single gateway instance. They hit: DNS, Azure Front Door, Cloud Load Balancer
- This component: Distributes traffic across multiple gateway instances, Performs health checks, Handles failures.
- Flow:

    Client
    ↓
    DNS / Azure Front Door
    ↓
    [ LB ]  → API Gateway instance A
            → API Gateway instance B
    ↓
    API Gateway (routing, auth, rate limit)
    ↓
    [ Service LB ]
    ↓
    Service Instance 1
    Service Instance 2
    Service Instance 3

---

## 9. Where should authentication be handled — at the API Gateway or inside each microservice? Why?

- It depends on the system design and security requirements.
- If authentication logic is common across services, such as validating JWT tokens or OAuth access tokens, it makes sense to 
  handle authentication at the API Gateway. This centralizes security, avoids duplication, and allows backend services to focus purely on business logic.
- However, authorization is often service-specific. Even after a request is authenticated at the gateway, individual services may need
  to enforce their own authorization rules based on domain logic, roles, or permissions.
- In more complex systems, a layered approach is used — authentication at the gateway and fine-grained authorization at the service level.
  This follows the principle of defense in depth and ensures services remain secure even if the gateway layer is bypassed.

-> Follow-up Question: Why not only gateway auth? Isn’t that enough?
Answer: Relying only on gateway authentication assumes the gateway can never be bypassed. In distributed systems, services may be accessed 
internally or via misconfigurations. Service-level authorization acts as a safety net and enforces domain-specific access control.

---

## 10. What’s the difference between DNS and Front Door?

DNS only resolves a domain name to an IP address, whereas Front Door provides intelligent global traffic routing, health checks, and failover before requests enter the backend system.

---